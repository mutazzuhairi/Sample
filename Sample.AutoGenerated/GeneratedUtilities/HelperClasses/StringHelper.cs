using System;
using System.Text;
using System.Linq;
using System.ComponentModel.DataAnnotations;
using Sample.AutoGenerated.GeneratedUtilities.SystemConstants;
using System.Xml.Linq;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace Sample.AutoGenerated.HelperClasses
{
    public static class StringHelper
    {
        public static string GetHeaderIndex(this IEnumerable<XElement> xElements, string tableName, IEnumerable<XAttribute> tableAttributes)
        {
            string finalAttributes = string.Empty;
            foreach (var property in xElements)
            {
                if (bool.Parse(property.Attribute("InActive").Value)) { continue; }
                if (bool.Parse(property.Attribute("IsDBField").Value))
                {
                    string fieldName = property.Attribute("FieldName").Value.Replace("\"", string.Empty);
                    if ((!string.IsNullOrEmpty(property.Attribute("UniqueField")?.Value) && bool.Parse(property.Attribute("UniqueField").Value)) ||
                        (!string.IsNullOrEmpty(property.Attribute("HasIndex")?.Value) && bool.Parse(property.Attribute("HasIndex").Value)))
                    {
                        if (!string.IsNullOrEmpty(finalAttributes))
                        {
                            finalAttributes += Environment.NewLine + AutoGeneratedConstatnts.Other.FOUR_SPACES;
                        }
                        if (!string.IsNullOrEmpty(property.Attribute("UniqueField")?.Value) && bool.Parse(property.Attribute("UniqueField").Value))
                        {
                            finalAttributes += "[Index(nameof(" + fieldName + "), Name = \"UQ_" + tableName + "_" + fieldName + "\", IsUnique = true)]";
                        }
                        else
                        {
                            finalAttributes += "[Index(nameof(" + fieldName + "), Name = \"IX_" + tableName + "_" + fieldName + "\")]";
                        }
                    }
                }
            }
            finalAttributes = AddIndexGroup(tableAttributes.Where(s => s.Name == "IndexGroup1").FirstOrDefault()?.Value.Replace("\"", string.Empty), tableAttributes.Where(s => s.Name == "IndexGroupUnique1").FirstOrDefault()?.Value, finalAttributes, tableName);
            finalAttributes = AddIndexGroup(tableAttributes.Where(s => s.Name == "IndexGroup2").FirstOrDefault()?.Value.Replace("\"", string.Empty), tableAttributes.Where(s => s.Name == "IndexGroupUnique2").FirstOrDefault()?.Value, finalAttributes, tableName);
            finalAttributes = AddIndexGroup(tableAttributes.Where(s => s.Name == "IndexGroup3").FirstOrDefault()?.Value.Replace("\"", string.Empty), tableAttributes.Where(s => s.Name == "IndexGroupUnique3").FirstOrDefault()?.Value, finalAttributes, tableName);
            finalAttributes = AddIndexGroup(tableAttributes.Where(s => s.Name == "IndexGroup4").FirstOrDefault()?.Value.Replace("\"", string.Empty), tableAttributes.Where(s => s.Name == "IndexGroupUnique4").FirstOrDefault()?.Value, finalAttributes, tableName);
            finalAttributes = AddIndexGroup(tableAttributes.Where(s => s.Name == "IndexGroup5").FirstOrDefault()?.Value.Replace("\"", string.Empty), tableAttributes.Where(s => s.Name == "IndexGroupUnique5").FirstOrDefault()?.Value, finalAttributes, tableName);

            return string.IsNullOrEmpty(finalAttributes) ? AutoGeneratedConstatnts.Other.REMOVE_LINE : finalAttributes;
        }

        private static string AddIndexGroup(string indexGroup, string indexGroupUnique, string finalAttributes, string tableName)
        {
            if (!string.IsNullOrEmpty(indexGroup))
            {
                if (!string.IsNullOrEmpty(finalAttributes))
                {
                    finalAttributes += Environment.NewLine + AutoGeneratedConstatnts.Other.FOUR_SPACES;
                }
                if (!string.IsNullOrEmpty(indexGroup) && !string.IsNullOrEmpty(indexGroupUnique) && bool.Parse(indexGroupUnique))
                {
                    var fields = "nameof(" + string.Join("), nameof(", indexGroup.Split(',').ToList())+")";
                    finalAttributes += "[Index("+ fields + ", Name = \"UQ_" + tableName + "_" + string.Join("_", indexGroup.Split(',').ToList()) + "\", IsUnique = true)]";
                }
                else
                {
                    var fields = "nameof(" + string.Join("), nameof(", indexGroup.Split(',').ToList()) + ")";
                    finalAttributes += "[Index("+ fields + ", Name = \"IX_" + tableName + "_" + string.Join("_", indexGroup.Split(',').ToList()) + "\")]";
                }
            }

            return finalAttributes;
         }

        public static string GetAttributes(this XElement field, IEnumerable<string> files = null, string entityType = "model")
        {
            string finalAttributes = string.Empty;
            bool isFieldPrimaryKey = field.Attribute("IsPrimaryKey")?.Value == null ? false :  bool.Parse(field.Attribute("IsPrimaryKey").Value);
            bool isFieldRequired = field.Attribute("IsRequired")?.Value == null ? false : bool.Parse(field.Attribute("IsRequired").Value);
            bool isFieldMaxLength = field.Attribute("IsMaxLength")?.Value ==null ? false : bool.Parse(field.Attribute("IsMaxLength").Value);
            int fieldMaxLength = field.Attribute("MaxLength")?.Value == null ? 0 :  int.Parse(field.Attribute("MaxLength").Value);
            int fieldMinLength = field.Attribute("MinLength")?.Value == null ? 0 : int.Parse(field.Attribute("MinLength").Value);
            if (isFieldPrimaryKey)
            {
                if (!string.IsNullOrEmpty(finalAttributes))
                {
                    finalAttributes += Environment.NewLine + AutoGeneratedConstatnts.Other.NINE_SPACES;
                }
                finalAttributes += "[Key]";
            }
            if (isFieldRequired)
            {
                if (!string.IsNullOrEmpty(finalAttributes))
                {
                    finalAttributes += Environment.NewLine + AutoGeneratedConstatnts.Other.NINE_SPACES;
                }
                finalAttributes += "[Required]";
            }
            if (field.Attribute("FieldDataType").Value.Replace("\"", string.Empty).ConverteCSharpGeniricTypeToCamelCase(field, files) == AutoGeneratedConstatnts.SystemTypes.STRING)
            {
                if (!string.IsNullOrEmpty(finalAttributes))
                {
                    finalAttributes += Environment.NewLine + AutoGeneratedConstatnts.Other.NINE_SPACES;
                }
                if (entityType == "model")
                {
                    if (field.Attribute("FieldDataType").Value.Replace("\"", string.Empty) == AutoGeneratedConstatnts.MetaDataTypes.TEXT)
                    {
                        if (isFieldMaxLength)
                        {
                            finalAttributes += "[Column(TypeName = \"varchar(max)\")]";
                        }
                        else
                        {
                            finalAttributes += "[Column(TypeName = \"varchar\")]";
                        }
                    }
                    else
                    {
                        if (isFieldMaxLength)
                        {
                            finalAttributes += "[Column(TypeName = \"nvarchar(max)\")]";
                        }
                        else
                        {
                            finalAttributes += "[Column(TypeName = \"nvarchar\")]";
                        }
                    }
                }
                if (!isFieldMaxLength)
                {
                    if (!string.IsNullOrEmpty(finalAttributes))
                    {
                        finalAttributes += Environment.NewLine + AutoGeneratedConstatnts.Other.NINE_SPACES;
                    }
                    if (fieldMinLength == 0)
                    {
                        finalAttributes += "[StringLength(" + fieldMaxLength + ")]";
                    }
                    else
                    {
                        finalAttributes += "[StringLength(" + fieldMaxLength + ", MinimumLength = " + fieldMinLength + ")]";
                    }
                }
            }

            return string.IsNullOrEmpty(finalAttributes) ? AutoGeneratedConstatnts.Other.REMOVE_LINE : finalAttributes;
        }

        public static string Pluralize(this string value)
        {
            if (value.Length == 1)
                return value;
            else if (value.EndsWith(AutoGeneratedConstatnts.Other.Y))
                return value.Substring(0, value.Length - 1) + AutoGeneratedConstatnts.Other.IES;
            return value + AutoGeneratedConstatnts.Other.S;
        }
        public static string RemoveGarbageLinesFromString(this string text, string searchFor = AutoGeneratedConstatnts.Other.REMOVE_LINE)
        {

            var lines = text.Split(new string[] { System.Environment.NewLine },
                        StringSplitOptions.None)
                        .Where(s => !s.Contains(searchFor)).ToArray();

            string textCleaned = string.Join(System.Environment.NewLine, lines);

            return textCleaned;
        }

        public static string GetAttributeAsText(object attribute)
        {
            string finalAttributes = AutoGeneratedConstatnts.Other.LEFT_SQUARE_BRACKET + attribute.GetType().Name.Split(AutoGeneratedConstatnts.Attributes.ATTRIBUTE)[0];
            switch (attribute.GetType().Name.ToLower())
            {
                case AutoGeneratedConstatnts.Attributes.STRING_LENGTH_ATTRIBUTE:
                    {
                        var stringLengthAttribute = (StringLengthAttribute)attribute;
                        finalAttributes += AutoGeneratedConstatnts.Other.LEFT_BRACKET + (stringLengthAttribute.MinimumLength != 0 ?
                                                  stringLengthAttribute.MinimumLength + AutoGeneratedConstatnts.Other.COMMA : string.Empty) +
                                                  stringLengthAttribute.MaximumLength +
                                           AutoGeneratedConstatnts.Other.RIGHT_BRACKET +
                                           AutoGeneratedConstatnts.Other.RIGHT_SQUARE_BRACKET;
                        break;
                    }
                case AutoGeneratedConstatnts.Attributes.MAX_LENGTH_ATTRIBUTE:
                    {
                        var stringLengthAttribute = (MaxLengthAttribute)attribute;
                        finalAttributes += AutoGeneratedConstatnts.Other.LEFT_BRACKET +
                                            stringLengthAttribute.Length + AutoGeneratedConstatnts.Other.RIGHT_BRACKET +
                                           AutoGeneratedConstatnts.Other.RIGHT_SQUARE_BRACKET;
                        break;
                    }
                case AutoGeneratedConstatnts.Attributes.MIN_LENGTH_ATTRIBUTE:
                    {
                        var stringLengthAttribute = (MinLengthAttribute)attribute;
                        finalAttributes += AutoGeneratedConstatnts.Other.LEFT_SQUARE_BRACKET + attribute.GetType().Name.Split(AutoGeneratedConstatnts.Attributes.ATTRIBUTE)[0] +
                                           AutoGeneratedConstatnts.Other.LEFT_BRACKET + stringLengthAttribute.Length +
                                           AutoGeneratedConstatnts.Other.RIGHT_BRACKET +
                                           AutoGeneratedConstatnts.Other.RIGHT_SQUARE_BRACKET;
                        break;
                    }
                default:
                    {
                        finalAttributes += AutoGeneratedConstatnts.Other.RIGHT_SQUARE_BRACKET;
                        break;
                    }

            }

            return finalAttributes;
        }

        public static string CSharpTypeName(this XElement field, string t4Type = null, IEnumerable<string> files = null)
        {
            var name = field.Attribute("FieldDataType").Value.Replace("\"", string.Empty).ConverteCSharpGeniricTypeToCamelCase(field, files);

            if (!string.IsNullOrEmpty(t4Type) && !AutoGeneratedConstatnts.SystemTypes.SYSTEM_TYPES_LIST.Contains(name))
            {
                return name += t4Type;
            }

            return ConverteCSharpTypeNameToRightSyntax(name, field);
        }

        public static string TypeScriptTypeName(this XElement field, string t4Type = null, IEnumerable<string> files = null)
        {
            var name = field.Attribute("FieldDataType").Value.Replace("\"", string.Empty).ConverteTypeScriptGeniricTypeToCamelCase(field, files);

            if (!string.IsNullOrEmpty(t4Type) && !AutoGeneratedConstatnts.TypeScriptTypes.TYPESCRIPT_TYPES_LIST.Contains(name))
            {
                return name += t4Type;
            }

            return name;
        }

        public static string ConverteCSharpGeniricTypeToCamelCase(this string name, XElement field = null, IEnumerable<string> files = null)
        {

            switch (name)
            {
                case AutoGeneratedConstatnts.MetaDataTypes.TEXT:
                case AutoGeneratedConstatnts.MetaDataTypes.N_TEXT:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.STRING;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.LONG:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.LONG;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.INTEGER:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.INTEGER;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.DECIMAL:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.DECIMAL;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.DOUBLE:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.DOUBLE;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.DATETIME:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.DATETIME;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.DATETIMEOFFSET:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.DATETIMEOFFSET;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.BOOLEAN:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.BOOLEAN;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.BYTE:
                    {
                        name = AutoGeneratedConstatnts.SystemTypes.BYTE;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.LOOKUP:
                    {
                        name = GetIdTypeFromLookUpField(field, files).ConverteCSharpGeniricTypeToCamelCase(field, files);
                        break;
                    } 
            }
            return name;
        }

        public static string ConverteTypeScriptGeniricTypeToCamelCase(this string name, XElement field = null, IEnumerable<string> files = null)
        {

            switch (name)
            {
                case AutoGeneratedConstatnts.MetaDataTypes.TEXT:
                case AutoGeneratedConstatnts.MetaDataTypes.N_TEXT:
                    {
                        name = AutoGeneratedConstatnts.TypeScriptTypes.STRING;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.LONG:
                case AutoGeneratedConstatnts.MetaDataTypes.INTEGER:
                case AutoGeneratedConstatnts.MetaDataTypes.DECIMAL:
                case AutoGeneratedConstatnts.MetaDataTypes.DOUBLE:
                    {
                        name = AutoGeneratedConstatnts.TypeScriptTypes.NUMBER;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.DATETIME:
                case AutoGeneratedConstatnts.MetaDataTypes.DATETIMEOFFSET:
                    {
                        name = AutoGeneratedConstatnts.TypeScriptTypes.DATE;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.BOOLEAN:
                    {
                        name = AutoGeneratedConstatnts.TypeScriptTypes.BOOLEAN;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.BYTE:
                    {
                        name = AutoGeneratedConstatnts.TypeScriptTypes.ANY;
                        break;
                    }
                case AutoGeneratedConstatnts.MetaDataTypes.LOOKUP:
                    {
                        name = GetIdTypeFromLookUpField(field, files).ConverteTypeScriptGeniricTypeToCamelCase(field, files);
                        break;
                    }
            }
            return name;
        }


        private static string GetIdTypeFromLookUpField(XElement field = null, IEnumerable<string> files = null)
        {
            string baseIdType = "";
            if (field != null)
            {
                var lookUpTableName = field.Attribute("LookUpTableName").Value.Replace("\"", string.Empty);
                var entityFiles = files != null? files: Directory.EnumerateFiles("../../../../Sample.BLLayer/EntityFiles", "*.fxml");
                var lookUpTableNamePath = entityFiles.Where(s => s.EndsWith("\\" + lookUpTableName + ".fxml")).FirstOrDefault();
                if (entityFiles != null)
                {
                    XDocument fxmlFile;
                    try
                    {
                        fxmlFile = XDocument.Load(lookUpTableNamePath);
                        baseIdType = fxmlFile.Root.Attributes().Where(s => s.Name == "BaseIdType").FirstOrDefault().Value.Replace("\"", string.Empty).ConverteCSharpGeniricTypeToCamelCase();

                    }
                    catch (Exception)
                    {
                        throw new NotImplementedException();
                    }

                }
                else
                {
                    throw new FileNotFoundException();
                }
            }

            return baseIdType;
        }


        private static string ConverteCSharpTypeNameToRightSyntax(string typeName, XElement field)
        {
            var stringBuilder = new StringBuilder();
            stringBuilder.Append(typeName);
            if ((!string.IsNullOrEmpty(field.Attribute("IsNullable")?.Value) && bool.Parse(field.Attribute("IsNullable").Value)) &&
                (string.IsNullOrEmpty(field.Attribute("IsRequired")?.Value) || !bool.Parse(field.Attribute("IsRequired").Value)))
            {
                switch (typeName)
                {
                    case AutoGeneratedConstatnts.SystemTypes.STRING:
                    case AutoGeneratedConstatnts.SystemTypes.BYTE:
                        {
                            
                            break;
                        }
                    default:
                        {
                            stringBuilder.Append(AutoGeneratedConstatnts.Other.QUESTION_MARK);
                            break;
                        }
                }

            }
            return stringBuilder.ToString();
        }

        public static string SplitByCapital(this string str, string splitedBy = "-")
        {
            var splitByCapital = new Regex(@"
                (?<=[A-Z])(?=[A-Z][a-z]) |
                 (?<=[^A-Z])(?=[A-Z]) |
                 (?<=[A-Za-z])(?=[^A-Za-z])", RegexOptions.IgnorePatternWhitespace);
            str = splitByCapital.Replace(str, splitedBy).ToLower();
            return str;
        }
        public static string FirstCharToLowerCase(this string str)
        {
            if (string.IsNullOrEmpty(str) || char.IsLower(str[0]))
                return str;

            return char.ToLower(str[0]) + str.Substring(1);
        }

        /// <summary>
        /// Convert snake_case to PascalCase(UpperCamel).
        /// </summary>
        /// <param name="snakeCaseString">snake_case string.</param>
        /// <returns>PascalCase string.</returns>
        public static string ToPascalCase(this string snakeCaseString)
            => string.IsNullOrEmpty(snakeCaseString) ?
                snakeCaseString : ToCamelCaseInner(snakeCaseString.AsSpan(), true);

        /// <summary>
        /// Convert snake_case to camelCase(lowerCamel).
        /// </summary>
        /// <param name="snakeCaseString">snake_case string.</param>
        /// <returns>camelCase string.</returns>
        public static string ToCamelCase(this string snakeCaseString)
            => string.IsNullOrEmpty(snakeCaseString) ?
                snakeCaseString : ToCamelCaseInner(snakeCaseString.AsSpan(), false);

        /// <summary>
        /// Inner Method for <see cref="ToPascalCase(string)"/> and <see cref="ToCamelCase(string)"/>.
        /// </summary>
        /// <param name="source">snake_case chars span.</param>
        /// <param name="isUpper">First Letter is Upper or Lower.</param>
        /// <returns>(Upper|Lower) camelCase string.</returns>
        private static string ToCamelCaseInner(ReadOnlySpan<char> source, bool isUpper)
        {
            // if length is short, use stackalloc to avoid `new`.
            // TODO: use ArrayPool to avoid `new` completely.
            var buffer = source.Length <= 100 ?
                stackalloc char[source.Length] : new char[source.Length];

            int written = 0;
            foreach (char c in source)
            {
                if (c == AutoGeneratedConstatnts.Other.UNDER_SCORE_CHAR)
                {
                    // (written != 0) means "Is Not First Letter".
                    // if camelCase and first letter, (isUpper | "Is Not First Letter") is false.
                    // if PascalCase and first letter, (isUpper | "Is Not First Letter") is true.
                    // if not first letter, (isUpper | "Is Not First Letter") is true whether isUpper is true or not.
                    isUpper |= (written != 0);
                    continue;
                }

                buffer[written++] = isUpper ? char.ToUpperInvariant(c) : char.ToLowerInvariant(c);
                isUpper = false;
            }
            return (written == 0) ? string.Empty : new string(buffer.Slice(0, written));
        }
    }
}
